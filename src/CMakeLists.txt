cmake_minimum_required(VERSION 3.1)

#Construct R.lib if we're using Visual studio on Windows
if(${CMAKE_CXX_COMPILER_ID} STREQUAL MSVC)
	#R does not appear to tell us whether a debug build was selected, so just build a release build every time 
	message(STATUS "Checking that 64-bit R was selected")
	execute_process(COMMAND ${R_COMMAND} --no-restore --no-save -e "q()" OUTPUT_VARIABLE R_OUTPUT)
	string(FIND "${R_OUTPUT}" "64-bit" R_OUTPUT_64_BIT_INDEX)
	string(FIND "${R_OUTPUT}" "32-bit" R_OUTPUT_32_BIT_INDEX)
	if(NOT ${R_OUTPUT_32_BIT_INDEX} EQUAL -1)
		message(FATAL_ERROR "Checking that 64-bit R was selected - 32-bit R found")
	elseif(${R_OUTPUT_64_BIT_INDEX} EQUAL -1)
	 	message(STATUS ${R_OUTPUT})
		message(FATAL_ERROR "Checking that 64-bit R was selected - Unable to identify as either 64 or 32 bit")
	endif()
	message(STATUS "Checking that 64-bit R was selected - passed")

	message(STATUS "Checking that 64-bit compiler was selected")
	execute_process(COMMAND ${CMAKE_CXX_COMPILER} ERROR_VARIABLE COMPILER_OUTPUT_STRING OUTPUT_QUIET)
	string(FIND "${COMPILER_OUTPUT_STRING}" x86 COMPILER_OUTPUT_STRING_X86_INDEX)
	if(NOT ${COMPILER_OUTPUT_STRING_X86_INDEX} EQUAL -1)
		message(FATAL_ERROR "Checking that 64-bit compiler was selected - FAILED\nPlease ensure that you select the x64 developer tools prompt")
	endif()
	string(FIND "${COMPILER_OUTPUT_STRING}" "x64" COMPILER_OUTPUT_STRING_X64_INDEX)
	if(${COMPILER_OUTPUT_STRING_X64_INDEX} EQUAL -1)
		message(FATAL_ERROR "Checking that 64-bit compiler was selected - FAILED\nPlease ensure that you select the x64 developer tools prompt")
	endif()
	message(STATUS "Checking that 64-bit compiler was selected - passed")

	#If we're using MSVC, work out where lib.exe is
	get_filename_component(COMPILER_PATH "${CMAKE_CXX_COMPILER}" DIRECTORY CACHE)
	message(STATUS "Searching for lib.exe")
	find_program(LIB_EXECUTABLE lib PATHS ${COMPILER_PATH})
	if(${LIB_EXECUTABLE} STREQUAL LIB_EXECUTABLE-NOTFOUND)
		message(FATAL_ERROR "Searching for lib.exe - not found")
	else()
		message(STATUS "Searching for lib.exe - found")
	endif()

	#If we're using MSVC, work out where dumpbin.exe is
	message(STATUS "Searching for dumpbin.exe")
	find_program(DUMPBIN_EXECUTABLE dumpbin PATHS ${COMPILER_PATH})
	if(${DUMPBIN_EXECUTABLE} STREQUAL DUMPBIN_EXECUTABLE-NOTFOUND)
		message(FATAL_ERROR "Searching for dumpbin.exe - not found")
	else()
		message(STATUS "Searching for dumpbin.exe - found")
	endif()

	message(STATUS "Generating import library for R.dll")
	file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/R.def" "LIBRARY R\n")
	file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/R.def" "EXPORTS\n")
	execute_process(COMMAND "${DUMPBIN_EXECUTABLE}" /exports "${R_HOME}/bin/x64/R.dll" ERROR_QUIET OUTPUT_VARIABLE DUMPBIN_OUTPUT)
	#Strip off the junk at the start and end
	string(REGEX MATCHALL "[ |\t]+[0-9]+[ |\t]+[0-9A-F]+[ |\t]+0[0-9A-F]+[ |\t]+[^\n|\r]+\n" R_EXPORTS_LIST_UNFILTERED "${DUMPBIN_OUTPUT}")
	foreach(symbolline IN LISTS R_EXPORTS_LIST_UNFILTERED)
		string(REGEX REPLACE "[ |\t]+[0-9]+[ |\t]+[0-9A-F]+[ |\t]+0[0-9A-F]+[ |\t]+([^\n|\r]+)\n" "\t\\1" symbol "${symbolline}")
		file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/R.def" "${symbol}\n")
	endforeach(symbolline)
	execute_process(COMMAND "${LIB_EXECUTABLE}" /MACHINE:X64 /nodefaultlib "/def:${CMAKE_CURRENT_BINARY_DIR}/R.def" "/out:${CMAKE_CURRENT_BINARY_DIR}/R.lib" ERROR_QUIET OUTPUT_QUIET)
	file(REMOVE "${CMAKE_CURRENT_BINARY_DIR}/R.def")
	if(NOT EXISTS "${CMAKE_CURRENT_BINARY_DIR}/R.lib")
		message(FATAL_ERROR "Generating import library for R.dll - Error R.lib not found")
	endif()
	message(STATUS "Generating import library for R.dll - done")

	add_definitions(-Dsnprintf=_snprintf)

	#Put a Makefile.win in the source directory
	find_program(FULL_MAKE_PROGRAM nmake)
	set(FULL_MAKE_PROGRAM "\"${FULL_MAKE_PROGRAM}\" /f ")
	configure_file(${CMAKE_CURRENT_SOURCE_DIR}/Makefile.in ${CMAKE_CURRENT_BINARY_DIR}/Makefile.win @ONLY)
endif()

#Make sure everything installed to the right place
set(CMAKE_INSTALL_PREFIX "${PROJECT_SOURCE_DIR}")

#Now add the shared libarry target
set(SourceFiles alleleDataErrors.cpp checkHets.cpp combineGenotypes.cpp crc32.cpp estimateRF.cpp estimateRFCheckFunnels.cpp estimateRFSpecificDesign.cpp fourParentPedigreeRandomFunnels.cpp funnelsToUniqueValues.cpp generateGenotypes.cpp getFunnel.cpp intercrossingAndSelfingGenerations.cpp markerPatternsToUniqueValues.cpp orderFunnel.cpp recodeFoundersFinalsHets.cpp register.cpp replaceHetsWithNA.cpp convertGeneticData.cpp sortPedigreeLineNames.cpp matrixChunks.cpp rawSymmetricMatrix.cpp dspMatrix.cpp preClusterStep.cpp hclustMatrices.cpp mpMap2_openmp.cpp order.cpp impute.cpp arsa.cpp arsaRaw.cpp)
set(HeaderFiles alleleDataErrors.h combineGenotypes.h estimateRFCheckFunnels.h estimateRFSpecificDesign.h generateGenotypes.h intercrossingAndSelfingGenerations.h orderFunnel.h recodeHetsAsNA.h checkHets.h crc32.h estimateRF.h funnelsToUniqueValues.h getFunnel.h markerPatternsToUniqueValues.h recodeFoundersFinalsHets.h sortPedigreeLineNames.h unitTypes.hpp fourParentPedigreeRandomFunnels.h matrixChunks.h rawSymmetricMatrix.h dspMatrix.h matrices.hpp constructLookupTable.hpp probabilities.hpp probabilities2.hpp probabilities4.hpp probabilities8.hpp preClusterStep.h hclustMatrices.h mpMap2_openmp.h order.h impute.h arsa.h arsaRaw.h)
add_library(mpMap2 SHARED ${SourceFiles} ${HeaderFiles} ${mpMap2_MOC_SOURCES})
target_link_libraries(mpMap2 PRIVATE Rcpp)
target_include_directories(mpMap2 PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/../inst/include ${CMAKE_CURRENT_SOURCE_DIR})
target_compile_definitions(mpMap2 PRIVATE CUSTOM_STATIC_RCPP USE_OPENMP)
find_package(OpenMP REQUIRED)
set_property(TARGET mpMap2 APPEND PROPERTY COMPILE_FLAGS ${OpenMP_CXX_FLAGS})
set_property(TARGET mpMap2 APPEND PROPERTY LINK_FLAGS ${OpenMP_CXX_FLAGS})
if(NOT(CMAKE_CXX_COMPILER_ID MATCHES "Intel"))
	target_compile_features(mpMap2 PUBLIC cxx_rvalue_references)
else()
	target_compile_options(mpMap2 PUBLIC "-std=c++11")
endif()

#Ensure that it's installed to the right place
if(WIN32)
	if("${CMAKE_GENERATOR}" STREQUAL "NMake Makefiles")
		set_target_properties(mpMap2 PROPERTIES RUNTIME_OUTUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}../src/ PDB_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/../src/)
	else()
		foreach(BUILD_TYPE IN LISTS CMAKE_CONFIGURATION_TYPES)
			string(TOUPPER ${BUILD_TYPE} UPPER_BUILD_TYPE)
			set_target_properties(mpMap2 PROPERTIES RUNTIME_OUTPUT_DIRECTORY_${UPPER_BUILD_TYPE} ${CMAKE_CURRENT_BINARY_DIR}/../${BUILD_TYPE}/src/ PDB_OUTPUT_DIRECTORY_${UPPER_BUILD_TYPE} ${CMAKE_CURRENT_BINARY_DIR}/../${BUILD_TYPE}/src/)
		endforeach()
	endif()
	target_link_libraries(mpMap2 PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/R.lib)
	target_compile_definitions(mpMap2 PUBLIC _CRT_SECURE_NO_WARNINGS)
endif()
